# Сравнение производительности методов распараллеливания

* Вычисляется функция одного переменного на регулярной сетке по явной схеме.
* Используется формула: `p_next = (p_left + p_right)/2 + Math.random(1)`
* Код функции описан в файле [f.js](f.js)


### Последовательное вычисление
[sequential.js](sequential.js)

### Граф задач
[task-graph.js](task-graph.js)

### Ручное распараллеливание
[manual.js](manual.js)

### Метод итераций для графа задач
[iter-graph.js](iter-graph.js)

### Метод схем
[schema/trial-comp.js](schema/trial-comp.js)

## Подготовка и запуск теста

Система PPK работает в ОС Линукс (Дебиан) с установленными NodeJs и Python 3.

```
git clone https://github.com/pavelvasev/ppk.git
cd ppk
npm install
```

Запуск:
```
cd experiments/trial-v2
ITERS=1000 ./x-start-trial.py
```

## Эксперимент и результаты

2 варианта - на 1 тысячу и на 10 тысяч итераций. Мотивация для 10 тысяч - проверить как ведут себя алгоритмы на малых сетках на длительном времени. В каждом варианте:
* Запуски проведены в количестве 4х штук и времена взяты итоговые - минимальные из них.
* Процессор Ryzen 1700x.

Полученные результаты: Для 1 тысячи итераций: [results-1000](results-1000) Для 10 тысяч итераций: [results-10000](results-10000)

## Выводы

В случае 1 тысячи итераций на сетке 100 тыс:
* Граф задач показывает себя особенно плохо, начиная с P=8 работает дольше последовательного случая. Вероятная причина - задачи мелкозернистые, при P=8 это 12.5 тысяч ячеек на одну задачу.
* И ручное распараллеливание, и метод итераций ухудшают свою работу начиная с P=8.
Вероятная причина - их накладные расходы есть коммуникация между процессами исполнителей, и она превосходит вычислительную часть. Необходимо замерять отдельно, чем именно занимаются процессы исполнителей.
* Метод схем ведет себя лучше чем ручное распараллеливание, что подозрительно. Прим: при повышении кол-ва итераций до 10 тыс ситуация стабилизируется, и ручное становится лучше.

Общее наблюдение - по видимому, есть диапазоны "зернистости" задач, где разные методы хороши или плохи. Другими словами, "эффективность" метода есть функция от размера (зерна) задачи.
При этом, метод итераций в среднем показывает себя лучше, чем граф задач.
Требуются дополнительные исследования:
- более частые шаги по сетке,
- более сложные в плане коммуникации задачи,
- более значительное количество исполнителей.

# Особенности и изменения

* Дожидаемся завершения расчетов всех блоков
* Введен параметр ITERS для управления количеством итераций.
Повышение кол-ва итераций с 1000 до 10 тыс - привело к тому что manual стал работать быстрее чем schema.
* Решено брать не среднее время по запускам, а минимальное. 
Потому что в серии иногда наблюдался 1 выплеск (машина чем-то еще занялась) и он портит картину.
* Что измеряем: не включаем в замер времени загрузку начальных данных, но включаем накладные расходы на развертывание задач и процессов на исполнителях.