F-QUERY
Квери полезная фича. Делаем заявку на критерий, нам присылают сообщенрия - красота.

F-LISTS-USERNOTIFY
Надо уведомлеять пользвоателя если из списка удалили правило.
Это будет механизмом раннер-менеджеру узнавать что раннер отключился.
поскольку у раннер-менеджера нет прямой связи с раннерами - но ему вроде как и не надо
т.к. им он шлет хтпп-уведомления а раннеры ему шлют хтпп-уведомления..
ну так-то можно было наладить между ними прямую ws-связь чтобы узнавать об отключении.

F-EXEC-QUERY-ONE
сейчас ехек делает уникальный запрос на каждое сообщение. это тыркает мейна и качает раннеров
с учетом что там Н=1 получение результата сообщения. Ехек может по другому организовать получение сообщения. Например он может послать код, который следует выполнить ехеку для отправки сообщения.
Либо в форме спец-поля, либо в форме пост-операции.
Или например, как сейчас думаю, он может разместить 1 квери уникальный среди процессов, и просить присылать сообщения на него, с уникальным доп.полем и по нему разбираться. Благодаря этому не будут качаться таблицы мейна и раннер не будет телепаться закачивая однократные правила.

F-DEFINE-LIMITS
При определении абстракций надо также указывать и функцию расчета требуемых им ресурсов.

F-P-PROMISE
Результат exec() передавать как аргумент в другой exec. И тот другой запускается когда этот готов результат (аналогично подзадаче)

F-SEND-CMDLINE
утилита посылки из командной строки сообщений

F-VD
"визуальный отладчик"

F-KORZ-MANY-CRIT
возможность указать много критериев для корзинки

F-RUNNER-CLEANUP-TASK-NEEDS-ON-FAIL
При разворачивании нидс выявились ситуации:
- ошибка развертывания нидсы
- ошибка при работе уже развернутой нидсы.
В обоих случаях надо вычеркивать нидсу из списка развертнутых на раннере.
Решение: Если при вычислении задачи в раннере происходит ошибка, то он очищает все нидсы, использованные задачей.
Другие развернутые нидсы при этом остаются как были.

F-CONSIDER-PAYLOAD-LOCATION
При назначении задачи учитывать расположение данных и раннера.
Если они не совпадают то дается штрафной балл раннеру.
Кстати это и в промисах возникает..

F-WAIT-RUNNERS
Менеджер ждет указанное кол-во раннеров прежде чем начать раздавать задачи.
Полезно в случае чтобы например начальные данные не оказались на все 1 узле.
(был случай с кубиком 2023-05-20)

F-NODE-EXPORTS
Регистрирует проект с именем ppk чтобы можно было писать import .. from "ppk/..."
https://marian-caikovski.medium.com/how-to-import-a-module-from-the-root-of-a-node-js-project-edb3421534e3

F-TESTS-LOCAL
Файлы тестов расположены рядом с фичами, сервисами
Чтобы можно было сервис убрать и на его тесты не смотреть.

F-PAYLOAD-BYTES-COUNT
Сохранять размер нагрузки в клиентской структуре в поле bytes_count
Клиентская структура хранит набор нагрузок в массиве payload_info.
Это - "облегченное" представление структур данных, стандартных у нас (например в выгрузке результата раннера).
Размер нагрузки - позволяет подсчитывать limits ниды - объёмы требуемые для разворачивания ниды пейлоада.
Также может пригодится и при работе с общей памятью.
Доп идея - стандартизовать тип хранения. Может простая таблица типа float64 или что-то такое, мб нампи посмотреть
или другие структуры - там было что-то про тензоры.
+ важно, что это за байты. Пока они = колву сохраненного материала = объему развернутого. Но может быть и иначе, например разворачивается более сложная
структура чем массив. или упаковка в lzw..

F-KEEP-TASK-ID
Задача решена, у нее есть идентификатор, и по нему ссылаются
а) другие задачи, б) ниды развернутые на воркере с результатом этой задачи.
Сообразно, если там пейлоад - то развернут пейлоад.
И сообразно, при замене пейлоада на ниду пейлоада - надо сохранить этот идентификатор.
Чтобы при расчете нид он поучаствовал, и нида на воркере была бы использована.

F-NEEDS-DIFF
Раннер высылает раннер-менеджеру не весь список нидов. А только изменения от последней посылки - что добавилось, что удалилось. Потому что списки большие получаются.

F-JS-MAP-IS-FASTER
js Map существенно быстрее {}. Например перевод солвера runner_needs на map-у
дал выигрыш скорости расчета с 1мс на 0.3 мс..

F-SIMPLE
Для needs - исключение из расчетов при выборе исполнителя.
Например, нет нужды учитывать разверность результатов 
1) простых вычислений (т.к. они не содержат нагрузки и могут быть присланы на любой исполнитель быстро, прямо в аргументах задачи), 
2) примитивы when-all по той же причине.

==================== ноябрь 2023

F-TASK-SET-RUNNER
возможность чтобы пользователь сам указывал на каком раннере выполнять задачу.
для этого стало быть пользователю надо знать список раннеров (или хотя бы их айди). и уметь указывать айди этот при создании задачи.

F-RUNNERS-LIST
клиенту знать список раннеров (для F-TASK-SET-RUNNER)
как вариант м сделать через F-MAIN-SHARED-SETS

F-TASK-SET-RUNNER-DIRECT
из идей - пусть тогда задача напрямую в этот раннер и поступает, в его очередь.
в обход центра системы.

F-MAIN-SHARED-SETS js
вроде как получается удобно иметь общую память. из словарей.
в ней можно хранить список раннеров. да и другие вещи тоже.
но это можно реализовать по-разному.
- на памяти мейн
- на реакциях (реация - добавить в результат данные, а не отсылка)
- на выделенной общей памяти сервера некоторого, и явных посылках ему о добавлениях, и явных запросах этой очереди.

F-SHARED-DEFINES
стало невозможно присылать дефинес с каждым запросом (теперь не обязательно через раннер-менеджер все идет - а раньше раннер-менеджер копил все и высылал скопом). сообразно делаем как надо - а это через общие списки.

F-CALL-DEFINE
умение вызвать задачу, действие которого определен через define

F-RUNNER-FINISHED-NOMANAGER
раннер-менедждер больше не читает runner-finished ему не надо.
а мы т.о. убираем лишнюю передачу сообщений.

F-RUNNER-PROMISES
локальные сервер обещаний раннера. раннер пишет свои результаты в свой сервер.
без ходьбы в наружный сервер. и запрашивает аналогично.
вводится новое понятие промис - с каналами. каналы соответсвуют разбиению
прикладных данных. это позволяет задачам адресовать раннеры и их промиса-серверы.

F-PROMISES-CHANNELS
добавим промисам каналы. По умолчанию канал общий - "". для реализации F-RUNNER-PROMISES.

F-RESOURCES-ADDITIVE
учет ресурсов DeployedNeeds надо вести не через пересчет, а через добавление и удаление значений по мере развертывания-свертывания нидов. а то когда нидов становится тысяча - то полный пересчет долгое явление.